# 리스트

l = [1, 2, 3]
# 인덱스로 접근이 가능한 이유는
# 메모리에 연속적으로 저장
# 메모리의 시작 주소와 인덱스 등을 활용해서 계산하고, 원하는 데이터의 주소로 접근한다.

# Big-O <- 얼만큼 시간이 걸리는지
# O(1) <- 진짜 짧은 시간. 인덱스로 접근할 때 O(1)이 걸린다.
# Big-O를 쉽게 알아내는 방법은, for문의 개수를 보면서 어림잡으면 된다.
# for num in l:
#     for num in l:

# pop(0) <- 땡겨지는데 시간이 걸리기 때문에 맨 앞에꺼 뺄거면 deque
# pop의 최악은 O(N)이다. 그래서 주의해야된다. 맨 마지막꺼 뺄때만 사용하자.

# 투포인터 방식이 유용할 때가 많다.

# 인덱스를 다른 리스트에 기록해서 사용할 수도 있는 경우
l = [1000, 2, 1]
j = [-1] * (max(l) + 1) # 일단은 l에서 가장 큰 값을 갖는 크기만큼 초기화
# 중복된 값이나 너무 큰 값이 있으면 안 쓰는 게 좋다,

for i in range(len(l)):
    j[l[i]] = i
j = [-1, 2, 1, 0] # l에 있는 데이터들이 몇번째 인덱스에 있는지를 기록한다.

# int 4바이트
# 128MB <- 128 * 1024 KB <- 128 * 1024 * 1024 바이트
