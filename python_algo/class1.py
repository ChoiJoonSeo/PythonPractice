from pprint import pprint
# 들여쓰기 <- 인덴트 (스페이스 4개 혹은 탭)

def minus(x, y): # 기능은 더하기인데 이름은 빼기 <- 이상함... 이런 경우가 없어야 됨.
    return x + y

def z(x, y): # 함수 이름으로 어떤 기능인지 유추하기가 힘들어짐... 이런 식으로 이름을 짓지말자.
    return x + y

# 변수의 이름이나 함수의 이름, 클래스의 이름
my_name = 'cjs' # 스네이크 케이스
# 변수나 함수가 어떤 용도로 쓰이는지를 생각해서 이름을 짓는게 베스트다.
# 코드가 너무 길어지거나 이해하기 힘들어보이면, 주석으로 설명을 적어놓는게 좋다.
# class MyName: # 카멜(낙타) 케이스 <- 클래스의 이름을 지을 때만

# 타입 힌트: 어떤 데이터 타입인지 힌트를 주겠다.
a:int = 1 # 메모하는 기능
# 타입 힌트는 힌트의 역할은 하지만, 데이터 타입을 강제하지는 않기 때문에 조심해야 된다.

# range
range(5) # 0...4
range(1, 5) # 1...4
range(1, 5, 2) # 1, 3
range(5, 0, -1) #  5..1
# range는 항상 첫번째에서 시작을 해서 끝 숫자의 바로 전까지 진행한다.
l = [1, 2, 3] # 바로 메모리 1, 2, 3이 올라감.
range(1, 3 + 1) # next()로 호출될 때마다 메모리에 숫자가 올라감.

l = [1, 2, ... , 1000000000] # 코드를 적자마자 메모리를 차지함.
range(1000000000) # 사용할 때까지 메모리를 안 차지함
l2 = list(range(1, 4)) # [0, 1, 2, 3, 4]. 이때부터는 메모리를 바로 차지하지만, 코드를 쓸 때 편하다.


# enumerate <- 인덱스, 그 인덱스에 해당하는 값을 같이 활용할 수 있는 기능
for idx, value in enumerate([4, 5, 6]):
    print(idx, value) # 0,4 1,5 2,6


# 나눗셈
a = 1 / 3 # 소수점까지
a = 4 // 2 # 정수 몫만 나온다
d, m = divmod(5, 2) # 2와 1


# print
print('5') # 항상 한줄을 자동으로 띄운다.
print(5, end='')
joined = '\n'.join(['1', '2', '3']) # 문자열인데 끝에 줄바꿈이 없는 문자열임.
print(joined) # 얘는 기본적으로 줄바꿈을 만든다.
print(1, 2, 3, sep='***') # 1***2***3 빈 문자열을 설정하면 문자가 딱 달라붙는다.

# pass
def test():
    pass # 나중에 할 생각으로 에러 안 뜨게 하는 것
    raise NotImplementedError # 강제로 에러 띄워서 코딩을 강제하기
    # TODO 할 것 ~~~ 이러면 Pycharm에서 찾기 쉬워짐

# locals()
a = 1
l = [1, 2, 3]
l[0] = 16

pprint(locals()) # 디버깅 <- 버그를 잡겠다는 의미

# 리스트 내포(컴프리헨션)
list = [i for i in range(1,10+1)] # 가독성도 좋고 속도도 더 빠름
d = {i:'hi' for i in range(1, 10 + 1)} # 딕셔너리 초기화할때도 사용 가능하지만,
# defaultdict가 있어서 딱히 쓸 곳이 많지는 않다.

print(d['cjs']) # 일반 딕셔너리에서는 Error를 띄움. 코드가 off됨.

# d = defaultdict(int) # 0이 초기값이 됨
# print(d['cjs']) # 0이 출력됨

list = [i for i in [1,23,12,312,3,12,1,12,3,1,23,123,12,1,] if i % 2 == 0]
# 리스트 내포 안에 조건문과 for문을 같이 적으면 코드가 굉장히 길어질 수도 있다.
# 그래서 너무 길면 차라리 그냥 원래 하던대로 for문이랑 if문을 밖에서 쓰거나
# 하는 게 낫다.
# 가독성이 너무 떨어지면 안 좋은 코드라고 사람들이 인식함

# 조건문을 쓸 때
a = True # 변수 자체가 Boolean 이라면
if a: # a가 True인지 False인지를 판단하는 조건문
    pass
# if a == True 이렇게 쓸 필요 없다.

# True = 1 False = 0
n = 1
# if not n: 숫자 비교는 이런 식으로 쓰지 말라고 함..
if n == 0: # True False처럼 쓸 수 있는 숫자라도 이렇게 쓰는 게 더 의미가 있음.
    pass

# 리스트에 데이터가 들어있는지 확인할 때
list = []
if list: # 데이터가 들어있으면 True, 없으면 False 리턴
    pass # 데이터 들어있는 거 확인할 때는 그냥 조건문에 바로 넣는다.
